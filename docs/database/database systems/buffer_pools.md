---
tags: Database
---
# buffer pools

## 含义

buffer pool 是从磁盘读取的页面的内存缓存。
它本质上是在数据库内部分配的一个大内存区域，用于存储从磁盘获取的 page。

缓冲池的内存区域组织为固定大小页面的数组。每个数组条目称为一个 frame。
当 DBMS 请求 page 时，会将一个完全相同的副本放入 buffer pool 的其中一个 frame 中。然后，当请求 page 时，数据库系统可以首先搜索 buffer pool。如果找不到该 page，则系统将从磁盘获取该页的副本。

DBMS 可以用 [[os]] 的 Page Cache 来处理

### page table

为了方便查找，buffer pool 中还有额外的 meta data。
page table 是内存中的 [[哈希表]]，保存 page_id: frame_location。表中还有

- dirty-flag：当某个[[线程]]改变 page 内容时被设置
- pin/reference counter：当前读写 page 的线程数，大于 1 时不能被从内存中清除

## 优化策略

### multiple buffer pools

DBMS可以为不同的目的维护多个缓冲池(即每个数据库的缓冲池、每个页面类型的缓冲池)，每个缓冲池都可以采用为其中存储的数据量身定做的本地策略。此方法有助于减少锁存争用并提高局部性

### pre-fetching

DBMS还可以根据查询计划通过预取页面进行优化。然后，在处理第一组页面时，可以将第二组页面预取到缓冲池中。此方法通常由DBMS在顺序访问多个页面时使用

### scan sharing

查询游标可以重复使用从存储或运算符计算中检索的数据。这允许将多个查询附加到扫描表的单个游标上。如果一个查询开始扫描，并且已经有一个查询开始扫描，则DBMS将附加到第二个查询的游标。DBMS跟踪第二个查询与第一个查询的联接位置，以便在到达数据结构末尾时完成扫描

### buffer pool bypass

顺序扫描操作符不会将获取的页面存储在缓冲池中，以避免开销。相反，内存是正在运行的查询的本地内存。如果操作需要读取磁盘上连续的大序列页面，这种方法效果很好。缓冲池旁路还可用于临时数据(排序、连接)

## buffer 更新策略

- [[在线算法#LRU]]：队列里面维护最后一次访问每个 page 的时间戳，删除时删最旧的
- Clock：访问到的 page 组成一个圈，扫描过程中 page 被获得则 reference bit 设置为 1；然后 reference bit 如果是 为 0 则删掉，如果为 1 则设为 0

[//begin]: # "Autogenerated link references for markdown compatibility"
[os]: <../../operating system/os.md> "操作系统"
[哈希表]: ../../algorithm/data_structure/哈希表.md "哈希表"
[在线算法#LRU]: ../../algorithm/algorithms/在线算法.md "在线算法"
[//end]: # "Autogenerated link references"

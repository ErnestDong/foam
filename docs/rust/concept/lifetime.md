---
tags: rust
---
# 生命周期

生命周期，简而言之就是引用的有效作用域。生命周期的作用是防止悬垂引用，即引用的对象已经被释放，但是引用还在使用。

## 借用检查

为了保证[[Rust]] 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性

在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。

## 标注语法

生命周期的语法以 `'` 开头，名称往往是一个单独的小写字母，如果是引用类型的参数，那么生命周期会位于引用符号 `&` 之后，并用一个空格来将生命周期和引用参数分隔开，但在`mut`前。
生命周期的作用就是告诉编译器多个引用之间的关系，以便编译器可以在编译时进行借用检查。

```rust
// 该函数签名表明对于某些生命周期 `'a`，函数的两个参数都至少跟 `'a` 活得一样久，同时函数的返回引用也至少跟 `'a` 活得一样久。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // longest不知道`x`和`y`具体活多久，只要知道它们的作用域至少能持续`'a`这么长就行。
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

* 生命周期 `'static` 意味着能和程序活得一样久，例如字符串字面量和特征对象

## 生命周期的消除

编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。

1. **每一个引用参数都会获得独自的生命周期**
    例如一个引用参数的函数就有一个生命周期标注: `fn foo<'a>(x: &'a i32)`，两个引用参数的有两个生命周期标注:`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, 依此类推。
2. **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**，也就是所有返回值的生命周期都等于该输入生命周期
    例如函数 `fn foo(x: &i32) -> &i32`，`x` 参数的生命周期会被自动赋给返回值 `&i32`，因此该函数等同于 `fn foo<'a>(x: &'a i32) -> &'a i32`
3. **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**
    拥有 `&self` 形式的参数，说明该函数是一个 `方法`，该规则让方法的使用便利度大幅提升。

[//begin]: # "Autogenerated link references for markdown compatibility"
[Rust]: ../rust.md "rust"
[//end]: # "Autogenerated link references"

---
tags: CS
---
# C

## 程序就是状态机

C 语言的状态是 stack frame + PC + 全局变量，每执行一条语句状态就变一下。
初始状态是 `main(argc,argv)` ，迁移是执行 top frame 的 PC 语句，函数调用 push frame，返回 pop frame。

二进制文件下，也可以将程序看作是内存 M 和寄存器 R 的状态机。初始状态是加载 `加载器` libc，`main` 并非是程序的开始/结束。
在操作系统中，将程序看作是“计算”+ `syscall`，`syscall`利用中断把程序的状态全部交给操作系统，任其修改

两种状态机之间的映射是编译器，C 所有不可优化的部分都被翻译成了汇编。
**各种程序都在操作系统API `syscall` 和操作系统中的对象上构建**

## pthread.h

用于 [[多线程]] [[并发]]编程

线程的创建是在状态中新增一个栈帧列表并初始化；
线程的等待是在其他线程未执行完成时死循环。

### 原子性

程序/指令独占处理器执行的假设不成立，需要非原子操作上加锁。

绝大多数并发问题可以用一个队列解决：把大任务分解为小任务，worker thread去锁保护的队列里面取任务

### 顺序

编译器按照单线程程序优化代码，导致共享内存作为线程同步的失效

### 可见性

处理器也是一种状态机，会把汇编进一步编译成 $\mu$ ops，因为有乱序执行甚至投机执行、按序提交，多处理器上无法序列化，可能导致cache没有命中时先执行后面的代码

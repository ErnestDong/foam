---
tags: CSAPP
---
# 动态内存分配

内核维护一个`brk`指针指向[[堆]]的顶部，堆在[[虚拟内存]]中位于未初始化的数据之上

## 显式分配器的实现

如 [[C]] 中的 `malloc` 和 [[cpp]] 中的 `new`，实现要求的 workload 是

- 对一串分配释放请求，可以处理任意请求序列
- 立即响应请求，因而不能有类似 buffer 或重排的技巧
- 只使用堆
- 对齐块
- 不修改已经分配的块

目标是平衡最大化吞吐率和内存利用率。降低堆运行效率的是“碎片”，因而 allocator 试图维持少量的大空闲块而非大量的小空闲块，串联空闲块的数据结构是[[链表]]

## 垃圾收集器的实现

不需要手动管理内存的语言需要隐式的内存分配，称为 GC。GC 将内存视为一个有向可达[[图]]，有一组根节点(例如栈中的数据)和许多堆节点。由根节点无法到达的堆节点即为垃圾，需要 GC 清除

### Mark & Sweep

mark 阶段标记根节点和所有可达节点

### [[python]] 的 GC

python 引用计数为主，分代收集为辅，当引用数为 0 时清除。
函数内循环引用，函数结束后无法释放内存。

- 小整数[-5, 256]对象在解释器初始化时确定，相同的小整数是同一个 id
- 大整数每次都会生成新的 id
- 字符串驻留(intern)，相同的字符串指向相同的位置(字符串中不包含特殊字符)

```python
# 手动清除
import gc
def recur():
    a = [i for i in range(100_0000_0000)]
    b = [i for i in range(100_0000_0000)]
    a.append(b)
    b.append(a)
recur()
gc.collect()
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[堆]: ../algorithm/data_structure/堆.md "堆"
[虚拟内存]: 虚拟内存.md "虚拟内存"
[C]: ../cpp/C.md "C"
[cpp]: ../cpp/cpp.md "Cpp"
[链表]: ../algorithm/data_structure/链表.md "链表"
[图]: ../algorithm/data_structure/图.md "图"
[python]: ../python/python.md "python"
[//end]: # "Autogenerated link references"

---
tags: python
---
# 协程

调用任务就像调用函数一样，是消耗资源最小的多任务。[[协程]] 适合于需要等待的任务## async IO

## 关键字

### async

使用 async 之后，调用函数返回的不是一个 function 而是一个 coroutine 对象，传到 [[#event loop]] 里面才开始异步运行

### await

等待一个 async 的协程对象执行完毕

## 例子

in jupyter-python we use `await main()`, but in python file we use `asyncio.run(main())`

```python
import asyncio
async def fetch_data():
    print("start fetching")
    await asyncio.sleep(2)
    return {"data":1}
async def print_num():
    for i in range(10):
        print(i)
        await asyncio.sleep(0.5)
async def main():
    task1 = asyncio.create_task(fetch_data())
    task2 = asyncio.create_task(print_num())
    value = await task1
    print(value)
    await task2
await main()
```

```text
    start fetching
    0
    1
    2
    3
    {'data': 1}
    4
    5
    6
    7
    8
    9
```

## event loop

我们可以让一个耗时的任务在后台运行。当这个任务完成的时候，event loop 可以 'pick it up'。
[[爬虫#aiohttp]] 相对会快一些，且资源消耗小

```python
import asyncio
import aiohttp
result = []
def get_tasks(session):
    tasks = []
    for symbol in ["AAPL", "MSFT", "TSLA", "GOOG"]:
        tasks.append(session.get(url.format(symbol)))
async def get_symbols():
    async with aiohttp.ClientSession() as session:
        tasks = get_tasks(session)
        responses = asyncio.gather(*tasks)
        for response in responses:
            result.append(await response.json())
loop = asyncio.get_event_loop()
loop.run_until_complete(get_symbols())
loop.close()
# or
asyncio.run(get_symbols())
```

## Task 类

将一个 coroutine 对象通过 `asycio.create_task` 封装成 Task 对象(Future 类的子类)，可以获得任务执行的状态，进而对协程有更细致的控制

`task.result()` 在执行完成后得到 coroutine 的返回值

### 回调函数

callback 执行时间不确定，用于 task 任务执行完自动的操作，是同步函数，采用 `task.add_done_callback(callback)`

回调函数的参数是 task，只有一个。如果用其他参数需要 `partial` 才能回调

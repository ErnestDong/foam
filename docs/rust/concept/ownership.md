---
tags: rust
---
# ownership

[[rust]]通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查，不用手动[[动态内存分配]]/GC

## 所有权

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(`drop`)

### 移动

Rust 基本类型及其组合都是通过自动拷贝的方式来赋值的，但对于非基本类型，比如`String`，赋值时会发生所有权转移，即变量的所有权从一个变量转移到另一个变量，原变量不再有效。

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s);             // s 的值移动到函数里 ...
    // println!("{}", s)            // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域
    makes_copy(x);                  // x 应该移动函数里，
    println!("{}", x)               // 但 i32 是 Copy 的，所以在后面可继续使用 x
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}
```

### 拷贝

Rust 永远也不会自动创建数据的 “深拷贝”，必须手动调用 `clone` 方法。

## 引用

Rust 通过引用的方式来访问对象，而不是直接访问对象，允许使用值，但是不获取所有权。

**获取变量的引用，称之为借用(borrowing)**。常规引用是一个指针类型，指向了对象存储的内存地址。

### 可变引用与不可变引用

- 引用指向的值默认也是不可变的，如果需要可变引用，需要使用 `&mut`。
- 同一作用域，特定数据
  - 只能有一个可变引用
  - 可变引用与不可变引用不能同时存在

```rust
fn main() {
    let x = 5;
    let y = &x;
    assert_eq!(5, x);
    assert_eq!(5, *y);
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

### 悬垂引用

悬垂引用指指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。

## [[lifetime]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[rust]: ../rust.md "rust"
[动态内存分配]: ../../csapp/程序的执行/动态内存分配.md "动态内存分配"
[lifetime]: lifetime.md "lifetime"
[//end]: # "Autogenerated link references"

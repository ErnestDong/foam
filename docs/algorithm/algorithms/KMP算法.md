---
tags: algorithm
---

# KMP

字符串匹配算法是找到 text 中所有的有效偏移 s，使得在该有效偏移下， 长度为 m 的 pattern P 出现在长度为 n 的 text T 中。朴素匹配复杂度 $\Theta(m(n-m+1))$

## Rabin-Karp 算法

加入一个预处理过程，尽管最坏情况下和朴素匹配效率一样，但是平均情况下效率比较好。

把每个字符看成一个 d 为基数的数字，d 为字母表的大小。为了避免这个数太大，可以对一个素数取模意义下比较是否相等。这样做就存在伪命中点需要排除

## [[有限自动机]]

## KMP 算法

当 TEXT 与 Pattern 的某个字符不匹配时，你其实知道前面几个字符是什么。
KMP 算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。

怎么做到这一点呢？可以针对搜索词，算出一张部分匹配表（Partial Match Table）。
每当越到不匹配时，采用 `移动位数 = 已匹配的字符数 - 对应的部分匹配值` 的算法移动字符串，再进行匹配，直到匹配成功

对 Pattern，第 n 位的"部分匹配值"就是 P[:n] 的每一个"前缀"和 P[:n] 的每一个"后缀" 最长的共有元素的长度

[//begin]: # "Autogenerated link references for markdown compatibility"
[有限自动机]: ../../compilers/model/有限自动机.md "finite automata"
[//end]: # "Autogenerated link references"

---
tags: compilers
---
# LLVM

## IR

IR 输出一个DAG(有向无环[[图]])给后端，每个节点是一个指令，每个指令有一个或多个操作数，每个操作数是一个值，每个值有一个或多个用户，每个用户是一个指令。

设计理念：

- SSA表示，优化可以快速进行
  - SSA为静态单赋值，每个变量只有一个定义，每个变量只有一个使用，便于编译器遍历
  - 代码组织为三地址指令序列和假设无限寄存器
  - 三地址指令序列：每个指令有三个操作数，第一个操作数是目标，后两个操作数是源。可以分解为一个四元组`(op, src1, src2, dest)`
- IR 存储在磁盘，链接优化更容易实现

## 前端

前端将源代码转换为 IR，前端的工作包括：

- [[Lexical Analysis]]
- [[Parsing]]生成AST
- [[Semantic Analysis]]
- IR 生成

## 优化层

每一种优化方式叫做 Pass，分为

- Analyze Pass：分析 IR，生成分析结果
- Transform Pass：根据分析结果，对 IR 进行转换

## 后端

后端将 IR 转换为目标代码(或者汇编)，后端的工作包括：

- 指令选择：把 IR 中的指令转换为目标特定的 DAG 图
- 寄存器分配：无限虚拟寄存器转化为有限的实际寄存器，不够的时候挤到内存
- 指令调度
- 代码布局
- 代码组装

[//begin]: # "Autogenerated link references for markdown compatibility"
[图]: ../../algorithm/data_structure/图.md "图"
[Lexical Analysis]: <../procedure/Lexical Analysis.md> "词法分析"
[Parsing]: ../procedure/Parsing.md "语法分析"
[Semantic Analysis]: <../procedure/Semantic Analysis.md> "语义分析"
[//end]: # "Autogenerated link references"

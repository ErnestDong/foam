---
tags: OS
---

# 操作系统

**各种程序(无论是[[C]]、[[汇编]]还是二进制)都是一种状态机，在操作系统API `syscall` 和操作系统中的对象上构建**

## 状态机模型

CPU-reset 电路启动时，PC 默认从某个位置开始读，某些寄存器状态也确定。
PC 通常是跳转到硬件厂商的固件 firmware(BIOS/UEFI，保存在硬件上) 开始执行。
BIOS 约定，把第一个可引导设备的第一个扇区加载到物理内存的 512 字节处，把 PC 跳过去，系统交付给操作系统

firmware 和 boot loader共同完成操作系统的加载，初始化全局变量和栈，分配堆区，并为操作系统的 `main` 函数传递参数。
进入 C 代码后遵循 C 的程序语义，并由一些补充(AbstractMachineAPI)

之后加载第一个程序(systemd etc.)，第一个进程 init 永远不返回，init 用 `syscall` 创造整个世界(进程管理、文件管理、内存管理、网络……)

## [[并发]]

### [[Lock]] 与 [[Lock#死锁]]

### [[Synchronization]]

## 虚拟化

操作系统从用户进程上看就是一组 syscall，libc/[[shell]] 都通过 syscall 访问 kernel。
操作系统作为系统调用的管理者

### [[进程]]

### [[shell]] 的设计与实现

执行系统调用的“壳”，与内核交互

### [[C#libc 的实现]]

kernel 外边就是 libc 和 ABI

### [[context]]

## 持久化

### [[计算机组成#文件系统]]

### 设备驱动程序

设备在操作系统看来都是一组寄存器和协议，操作系统执行 read/write 以及 ioctl(读取/设置设备等状态)三个抽象的操作。
设备驱动背后可以没有真实设备，如 /dev/urandom 等模拟出来的设备

### 目录和文件 API

大部分 UNIX 文件系统所有文件都是 hard link，删除文件的 syscall 是 `unlink`

[//begin]: # "Autogenerated link references for markdown compatibility"
[C]: ../cpp/C.md "C"
[汇编]: ../csapp/程序的结构/汇编.md "程序的机器级表示"
[并发]: ../csapp/程序的通信/并发.md "并发"
[Lock]: 并发/Lock.md "Lock"
[Lock#死锁]: 并发/Lock.md "Lock"
[Synchronization]: 并发/Synchronization.md "Synchronization"
[shell]: ../tools/shell.md "shell"
[进程]: 虚拟化/进程.md "进程"
[C#libc 的实现]: ../cpp/C.md "C"
[context]: 虚拟化/context.md "上下文切换"
[计算机组成#文件系统]: ../csapp/计算机组成/计算机组成.md "计算机组成"
[//end]: # "Autogenerated link references"

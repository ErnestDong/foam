---
tags: CS
---
# mysql

## [[sql]]

## Join 算法

Join 可以被抽象为两个 `for` loop，里外两个迭代的表成为 inner/outer table，DBMS 总是用较小的表作为 outer table。
假设 R 表由 M 个 page/m 个 tuple 组成，S 表由 N 个 page/n 个 tuple 组成，S 为 inner table

- Nested Loop Join
  - 简单循环迭代复杂度 $O(M+mN)$
  - 采用 block 比较 $O(M+MN)$
    - 如果 DBMS 有 B 个 buffer 放数据，其中两个用来放 inner 和 outer table，复杂度降为 $M+MN/(B-2)$
  - 如果有每块有 C 个 tuple 的[[index]]，复杂度为 $M+mC$
- Sort-Merge Join：先对两个表排序，然后合并，快于 Nested 方法
- Hash Join：根据它们的联接属性将元组分割成更小的块，几乎总是比 sort-based  算法快，但当数据已经按连接键排序时，以及当结果需要排序时 sort-based 更快

## 存储对象

### 视图

虚拟存在的表，只保存了 [[sql]] 的逻辑，不保存数据

```sql
CREATE OR REPLACE VIEW myview AS SELECT * FROM backtest;
```

### 存储过程

封装 SQL 语句进行重用

```sql
CREATE PROCEDURE p1(IN score INT, OUT res VARCHAR(10))
    BEGIN
        IF score >= 85 THEN
            SET res := "good";
        ELSE
            SET res := "bad";
        END IF;
    END;
CALL p1();
```

#### 存储函数

```sql
CREATE FUNCTION func(n INT)
RETURNS INT
BEGIN
    DECLARE TOTAL INT DEFAULT 0;
    WHILE n > 0 DO
          SET TOTAL := TOTAL + n;
          SET n := n + 1;
    END WHILE;
    RETURN TOTAL;
END;
```

### 触发器

是 INSERT/UPDATE/DELETE 的 hook ，确保数据的完整性、日志记录、数据校验

### 锁

- 全局锁
- 表级锁
- 行级锁

## [[index]]

## [[relation]]

### 关系的定义

$Relation=R(U,D,DOM,F)$ ，描述了关系包括哪些属性、属性来自哪些域、域和属性的关系，以及属性间的依赖关系

### 关系代数

抽象的查询语言，用对关系的运算表达查询，要素为：运算对象（关系）、运算符（集合运算符与关系运算符）、和运算结果

#### 关系代数运算

集合运算符 $\cup,-,\cap,\times$ 并、差、交、笛卡尔积

关系运算符 $\sigma,\Pi,\Join,\div$ 选择、投影、连接、除

选择：包括比较 $\gt,\ge,\lt,\le,\eq,\le\gt$ 和逻辑与或非 $\land, \lor, \neg$

投影：对查询结果只留下某个或某几个属性

除：保留 R 中满足 S 的，但是要去掉 S 的列

#### 关系的完整性

1. 实体完整性：主码唯一且完全
2. 参照完整性：外码要么为空，要么对应另一表的主码
3. 用户定义完整性

### 关系型数据库

包括数据定义语言 DDL 、数据查询语言 DQL ，数据操纵语言 DML 以及数据控制语言 DCL

[//begin]: # "Autogenerated link references for markdown compatibility"
[sql]: sql.md "mysql"
[index]: index.md "索引"
[relation]: relation.md "关系模型"
[//end]: # "Autogenerated link references"

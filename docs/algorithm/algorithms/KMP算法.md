---
tags: concrete algorithm,algorithm
---
# KMP算法

字符串匹配算法是找到 text 中所有的有效偏移 s，使得在该有效偏移下， 长度为 m 的 pattern P 出现在长度为 n 的 text T 中。朴素匹配复杂度 $\Theta(m(n-m+1))$

## Rabin-Karp 算法

加入一个预处理过程，尽管最坏情况下和朴素匹配效率一样，但是平均情况下效率比较好。

把每个字符看成一个 d 为基数的数字，d 为字母表的大小。为了避免这个数太大，可以对一个素数取模意义下比较是否相等。这样做就存在伪命中点需要排除

## 有限自动机

定义有限自动机 $M=((Q,q_0,A,\Sigma,\delta))$，其中

1. $Q$是状态的有限集合
2. $q_0 \in Q$ 为初始状态
3. $A \subseteq Q$ 为可接受状态
4. $\Sigma$ 为字母表
5. $\delta: Q \times \Sigma \rightarrow Q$ 为转移函数

在预处理阶段用$O(m|\Sigma|)$构造一个有限自动机，然后用 $\Theta(n)$ 的时间扫描 T 来决定是否匹配。构造有限自动机的关键是计算转移函数 $\delta$，

## KMP 算法

当 TEXT 与 Pattern 的某个字符不匹配时，你其实知道前面几个字符是什么。
KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。

怎么做到这一点呢？可以针对搜索词，算出一张部分匹配表（Partial Match Table）。
每当越到不匹配时，采用 `移动位数 = 已匹配的字符数 - 对应的部分匹配值` 的算法移动字符串，再进行匹配，直到匹配成功

对 Pattern，第 n 位的"部分匹配值"就是 P[:n] 的每一个"前缀"和 P[:n] 的每一个"后缀" 最长的共有元素的长度

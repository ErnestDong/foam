---
tags: OS
---

# 进程

进程是一个正在执行的程序的实例。通过进程，程序有独占处理器和内存的假象。
当设置了控制寄存器之后，进程运行在内核态，否则运行在用户态。

上下文 [[context]] 是 内容重新启动一个被强占的进程所需的状态，由一些状态的值描述。

## 进程的 crud

### `fork`：复制状态机

系统里面会有完全一样的两个独立的副本(寄存器、内存、库函数的内部状态)，除了 fork 的返回值(父进程为子进程编号，子进程返回值为 0)

父进程通过调用 `fork` 函数创建新的子进程，其特点是

- `fork` 会返回两次：一次返回给父进程，一次返回给子进程
- 并发执行，哪个先打印不确定
- 相同但是独立的地址空间
- 共享文件

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
int main() {
    pid_t pid;
    int x = 1;
    pid = fork();
    if (pid == 0) {
        // 返回给子进程
        printf("Child x=%d\n", ++x);
        exit(0);
    }
    // 返回给父进程
    printf("Parent x=%d\n", --x);
    exit(0);
}
```

```text
Parent x=0
Child x=2
Parent x=1
```

### `execve`：替换状态机

把状态机重置成某个程序的初始状态，当前状态全部抹掉

execve 可以调用 [[链接#可执行文件]]

### `exit`：销毁状态机

执行 `exit` 的状态机消失，其他状态机不变。
子进程终止时，保持在一个终止的状态(zombie)，直到被父进程回收

## 进程的地址空间

- vdso：只读的 `syscall`，不进入操作系统内核的系统调用
- vvar：vdso 的数据地址

syscall mmap 管理进程的地址空间，`mmap` 在进程里面创建一段新的映射/内存。通过 `mmap` 可以把文件映射到进程的地址空间里面，访问的时候再真正加载

## [[Lock]]

用互斥锁保护好数据，消灭数据竞争。可以利用 **动态程序分析** 把锁的顺序做成有向图检查是否有环检查死锁，

## 进程的[[Synchronization]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[context]: context.md "上下文切换"
[链接#可执行文件]: ../../csapp/程序的结构/链接.md "链接"
[Lock]: ../并发/Lock.md "Lock"
[Synchronization]: ../并发/Synchronization.md "Synchronization"
[//end]: # "Autogenerated link references"

---
tags: python
---

# 多线程

[[python]] 利用 Threading 实现多[[线程]]，多线程适合 IO 密集型的任务

## 写法

### 利用函数

```python
import threading

def some_function(args):
    pass

if __name__ == "__main__":
    args = (1,2)
    t = threading.Thread(target=some_function, args=args)
    t.start()
```

### 利用类继承

继承自 `threading.Thread` ，要实现 `run` 方法

```python
import threading

class MyThread(threading.Thread):
    def run(self):
        pass

if __name__ == "__main__":
    t = MyThread()
    t.start()
```

## 互斥[[Lock|锁]]

[[多线程]] 共享全局变量，但可能资源竞争（非原子操作会出错，例如+=）
可能竞争的地方加锁，如果已上锁则阻塞直到解开线程。上锁会影响性能

### Lock

```python
import threading

# create in global scope
mutex = threading.Lock()

# lock in thread
mutex.acquire()

# unlock in thread
mutex.release()
# or
with mutex:
    ...
```

### Rlock 递归锁

支持锁的嵌套(`lock.acquire()` 内部再 acquire 时，使用 Lock 会死锁)，性能略差

### [[Synchronization#信号量]]

限制同时最多访问资源的线程数

```python
semaphore = threading.BoundedSemaphore(values=5)
# release/acquire/with ...
```

## 线程池

一堆任务，几个线程，逐个处理。过多的线程会带来很多的开销

```python
from concurrent.futures import ThreadPoolExecutor

with ThreadPoolExecutor() as pool:
    # pool.map(func, args)
    for arg in args:
        pool.submit(func, arg)
```

## 线程间的通信

利用[[队列]]，线程之间共享全局变量

[//begin]: # "Autogenerated link references for markdown compatibility"
[python]: ../python.md "python"
[线程]: <../../operating system/并发/线程.md> "线程"
[Lock|锁]: <../../operating system/并发/Lock.md> "Lock"
[多线程]: 多线程.md "多线程"
[Synchronization#信号量]: <../../operating system/并发/Synchronization.md> "Synchronization"
[队列]: ../../algorithm/data_structure/队列.md "队列"
[//end]: # "Autogenerated link references"

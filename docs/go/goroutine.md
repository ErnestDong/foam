---
tags: go
---

# Go[[协程]]

## 语法

是一种有[[栈]][[协程]]开启一个协程只需要加`go`关键字：

```go
func main() {
    go Init()
    fmt.Println("main")
}

func Init() {
    fmt.Println("init")
}
```

## `chan`

用于同步不同协程的数据，`<-`指向谁代表从谁那里取数据，会阻塞

```Go
package main

import "fmt"

func main() {
    ch := make(chan string)
    go PrintChan(ch)
    recv := <-ch
    fmt.Println(recv)
}

func PrintChan(c chan string) {
    c <- "Channel Data"
}

```

- `chan`可以有缓冲区，例如`ch := make(chan string, 2)`，这样就可以先往`ch`里面放两个数据，然后再取，不会阻塞
  - 用无缓冲区的`chan`可以当做[[Lock]]来用
- `<-chan` 表示只读通道，`type Receiver = <-chan string`
- `chan<-` 表示只写通道，`type Sender = chan<- string`

### `WaitGroup`

等待多个协程完成，`Add`增加计数，`Done`减少计数，`Wait`阻塞直到计数为 0

```go
package main

import (
    "fmt"
    "sync"
)

func task(taskNum int, wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i < 3; i++ {
        fmt.Printf("task %d: %d\n", taskNum, i)
    }
}

func main() {
    var waitGroup sync.WaitGroup
    waitGroup.Add(3)
    go task(1, &waitGroup)
    go task(2, &waitGroup)
    go task(3, &waitGroup)
    waitGroup.Wait()
}
```

### `select`

相当于其他语言的`match`

```go
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    ch3 := make(chan string)
    go task1(ch1)
    go task2(ch2)
    go task3(ch3)
    select {
        case message1 := <-ch1:
            fmt.Println("ch1 received:", message1)
        case message2 := <-ch2:
            fmt.Println("ch2 received:", message2)
        case message3 := <-ch3:
            fmt.Println("ch3 received:", message3)
    }
}
```

### [[Lock]]

Go 也提供了锁`sync.Mutex`和条件变量`sync.Cond`

[//begin]: # "Autogenerated link references for markdown compatibility"
[协程]: ../python/multitasks/协程.md "协程"
[栈]: ../algorithm/data_structure/栈.md "栈"
[Lock]: <../operating system/并发/Lock.md> "Lock"
[//end]: # "Autogenerated link references"

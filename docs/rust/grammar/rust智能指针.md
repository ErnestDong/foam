---
tags: rust
---
# rust智能指针

智能指针往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了 `Deref` 和 `Drop` 特征：

> 与[[moderncpp]]的智能指针相比，rust的智能指针更像是RAII的实现

* `Deref` 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 `*T`
  * 对智能指针进行解引用时，实际上 Rust 为我们调用了`*(y.deref())`
* `Drop` 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作

```rust
// Deref实现
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}
```

## `Box<T>`堆对象分配

`Box` 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。相比其它智能指针，功能较为单一，可以在以下场景中使用它：

* 特意的将数据分配在堆上
* 数据较大时，又不想在转移所有权时进行数据拷贝
* 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时，比如

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

* 特征对象，用于说明对象实现了一个[[trait]]，而不是某个特定的类型

```rust
let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }), Box::new(Select { id: 2 })];
```

## `Rc<T>`引用计数智能指针

希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 `Rc` 成为数据值的所有者

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("hello, world"));
    let b = Rc::clone(&a);

    assert_eq!(2, Rc::strong_count(&a));
    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))
}
```

多线程需要用`Arc`，它是`Rc`的线程安全版本，但是性能上会有损耗

`Rc`持有所有权，`Weak` 不持有所有权，它仅仅保存一份指向数据的弱引用：如果你想要访问数据，需要通过 `Weak` 指针的 `upgrade` 方法实现，该方法返回一个类型为 `Option<Rc<T>>` 的值。

## `Cell<T>`和`RefCell<T>`

`Cell` 和 `RefCell` 都是用于在运行时进行借用检查的，它们都实现了 `UnsafeCell<T>` ，这个类型是一个内部可变性类型，它允许你在运行时改变数据的可变性

[//begin]: # "Autogenerated link references for markdown compatibility"
[moderncpp]: ../../cpp/moderncpp.md "Modern cpp"
[trait]: ../concept/trait.md "trait"
[//end]: # "Autogenerated link references"

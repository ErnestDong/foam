---
tags: algorithm
---

# LSM 树

LSM 树是一种基于磁盘的数据结构，并不是传统意义上的[[树]]，它的特点是利用顺序写来提高写性能，但因为分层的设计会稍微降低读性能，许多[[nosql]]都采用了 LSM 树作为底层数据结构。核心思想是保存一系列在后台合并的 SSTable

LSM 树会将所有的数据插入、修改、删除等操作保存在内存之中，当此类操作达到一定的数据量后，再批量地写入到磁盘当中。而在写入磁盘时，会和以前的数据做合并。在合并过程中，并不会像 [[B 树]]一样，在原数据的位置上修改，而是直接插入新的数据，从而避免了随机写。

## 结构

- memtable：内存中的数据，一种[[database systems/logging]]，用来记录所有的数据变更操作，当 memtable 达到一定的大小后，会将数据写入到磁盘中。可以使用[[跳表]]和树来实现
- immutable memtable：memtable 转变为 SSTable 的一种中间状态。目的是为了在转存过程中不阻塞写操作。写操作可以由新的 memtable 处理，而不用因为锁住 memtable 而等待
- SSTable：有序键值对集合，是 LSM 树组在磁盘中的数据的结构。如果 SSTable 比较大的时候，还可以根据键的值建立一个索引来加速 SSTable 的查询。
  - 落盘时，第一层 L0 不做排序，直接写入(可能有重复的数据)，后面的层做排序后写入
  - L0 满了后和 L1 进行 compaction 合并，通过布隆过滤器来去重
  - 合并方式类似[[归并排序]]

## 布隆过滤器

原理是将所有的 key 做 hash，然后将 hash 的结果作为 bit 数组的索引，将对应的 bit 设置为 1。这样，如果一个 key 不存在，那么它的 hash 值对应的 bit 一定是 0，如果是 1，那么它可能存在。这样就可以避免了对 SSTable 的全量扫描，从而提高了查询性能。

查找可能会有假阳性，但不会有假阴性

[//begin]: # "Autogenerated link references for markdown compatibility"
[树]: ../../algorithm/data_structure/树.md "树"
[nosql]: ../../database/sql/nosql.md "NoSQL"
[b 树]: <../../algorithm/data_structure/B 树.md> "B 树"
[database systems/logging]: <../../database/database systems/logging.md> "logging"
[跳表]: ../../algorithm/data_structure/跳表.md "跳表"
[归并排序]: ../../algorithm/sort/归并排序.md "归并排序"
[//end]: # "Autogenerated link references"

---
tags: concrete algorithm,algorithm
---
# 最短路径

## 单源最短路径

对于 s 到 v 的距离 d，通过与 u 相连的权重函数为 w 的点 v relax 操作为

```python
def relax(u,v,w):
    if v.d > u.d + w(u,v):
        v.d = u.d + w(u,v) # 更新 s 到 v 的距离
        v.pi = u # v 的前驱为 u
```

### Bellman-Ford

允许存在负权重的边，但是不可以有权重为负值的环。对边进行松弛操作来降低 s 到 v 的距离估计值 v

```python
def bellman_ford(G,w,s):
    for i in range(1, G.v):
        for u,v in G.E:
            relax(u,v,w)
    # 检查是否有权重为负的环
    for u,v in G.E:
        if v.d > u.d + w(u,v):
            return False
    return True
```

### Dijkstra

复杂度低于[[#Bellman-Ford]]，但是要求权重非负

## 所有节点对最短路径

[//begin]: # "Autogenerated link references for markdown compatibility"
[#Bellman-Ford]: 最短路径.md "最短路径"
[//end]: # "Autogenerated link references"

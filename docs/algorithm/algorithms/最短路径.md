---
tags: algorithm
---
# 最短路径

## 单源最短路径

对于 s 到 v 的距离 d，通过与 u 相连的权重函数为 w 的点 v relax 操作为

```python
def relax(u,v,w):
    if v.d > u.d + w(u,v):
        v.d = u.d + w(u,v) # 更新 s 到 v 的距离
        v.pi = u # v 的前驱为 u
```

### Bellman-Ford

允许存在负权重的边，但是不可以有权重为负值的环。对边进行松弛操作来降低 s 到 v 的距离估计值 v，复杂度 $O(V^2E)$

```python
def bellman_ford(G,w,s):
    for i in range(1, G.v):
        for u,v in G.E:
            relax(u,v,w)
    # 检查是否有权重为负的环
    for u,v in G.E:
        if v.d > u.d + w(u,v):
            return False
    return True
```

### Dijkstra

复杂度低于[[#Bellman-Ford]]，但是要求权重非负。用二叉[[堆]]实现的队列的复杂度为 $O(V+E \log V)$

在运行过程中维持的关键信息是一组节点集合 S，从源 s 到 S 的每个点的最短路径都找到，然后从剩下的节点里面找最短的节点 u，再对从 u 出发的边做 relax 操作

## 所有结点对最短路径

### Floyd 算法

采用了[[动态规划]]的思想，记 $f(i,j,k)$ 为点 i 到 j 的所有中间路径取自 $\{1,2,\dots, k\}$的最短路径的权重，则最短路径要么不经过 k 要么经过 k。即
$$
f(i,j,k)=
\begin{cases}
    w_{i,j} & k=0\\
    \min(f(i,j,k-1),f(i,k,k-1)+f(k,j,k-1)) & k\ge 1
\end{cases}
$$

### Johnson 算法

适用于稀疏图

[//begin]: # "Autogenerated link references for markdown compatibility"
[#Bellman-Ford]: 最短路径.md "最短路径"
[堆]: ../data_structure/堆.md "堆"
[动态规划]: ../动态规划.md "动态规划"
[//end]: # "Autogenerated link references"

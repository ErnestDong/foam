---
tags: rust
---
# trait

类似[[cpp]]的`concept`和其他语言的接口

## 特征作为方法

```rust
pub struct Weibo {
    pub username: String,
    pub content: String
}
pub trait Summary {
    // fn summarize(&self) -> String;
    fn summarize(&self) -> String{
        String::from("default")
    };// 可以有默认实现
}
impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}
```

## 特征作为参数

作为一种约束，可以使用任何实现了特征的类型作为该函数的参数

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

## 特征作为约束

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
// 可以简写为
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

- 多重约束

```rust
pub fn notify(item: &(impl Summary + Display)) {}
pub fn notify<T: Summary + Display>(item: &T) {}
```

- `where` 约束

```rust

fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
// 等价于
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
```

## 通过 `derive` 派生特征

被 `derive` 标记的对象会自动实现对应的默认特征代码，继承相应的功能。

例如 `Debug` 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 `println!("{:?}", s)` 的形式打印该结构体的对象。

## 特征对象

- 直到运行时，才能确定需要调用什么方法，这时就需要使用特征对象。
- 可以通过 `&` 引用或者 `Box<T>` [[rust智能指针]]的方式来创建特征对象。
- 特征对象的声明需要`dyn`关键字，但创建不用

[//begin]: # "Autogenerated link references for markdown compatibility"
[cpp]: ../../cpp/cpp.md "Cpp"
[rust智能指针]: ../grammar/rust智能指针.md "rust智能指针"
[//end]: # "Autogenerated link references"

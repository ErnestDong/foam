---
tags: DB
---
# transaction

## ACID

### Atomicity 原子性

确保事务中的所有操作要么发生，要么不发生。
> 可以依靠 [[logging#undo log]] 或 shadow paging (即复制一份 page 在复制的上面修改)来实现

### Consistency 一致性

如果每个事务都是一致的，并且在事务开始时数据库是一致的，那么当事务完成时，保证数据库是一致的。
> 通过持久性+原子性+隔离性来保证

### Isolation 隔离

隔离是指当一个事务执行时，应该有与其他事务隔离的错觉。
> 可以依靠 [[MVCC]] 来实现

### Durability 持久性

如果事务提交，则其对数据库的影响应该持续存在。
> 可以依靠 [[logging#redo log]] 来实现

## [[sql]]语法

```sql
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 10233276;
UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;
UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276;
COMMIT;
```

## [[Lock]]

### 2PL：Two-Phase Locking

第一阶段，事务向 DBMS 的 lock manager 请求锁；
当事务释放第一把锁时进入 shrinking 阶段，此阶段只能释放不能上锁

### 死锁

1. 侦测死锁：采用 waits-for [[图]]来侦测死锁，侦测到就选择一个事物 kill 掉
2. 预防死锁

### 锁的粒度

DBMS可以使用允许事务在系统中使用更多粗粒度锁的锁层次结构。
当事务获取此层次结构中某个对象的锁时，它将隐式获取其所有子对象的锁。

## 事务的[[进程|并行]]

在同时处理多个事务的时候，就可能出现的问题有：

- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致。

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（_read uncommitted_）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（_read committed_）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（_repeatable read_）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（_serializable_ ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

[//begin]: # "Autogenerated link references for markdown compatibility"
[logging#undo log]: logging.md "logging"
[MVCC]: MVCC.md "MVCC"
[logging#redo log]: logging.md "logging"
[sql]: ../sql/sql.md "mysql"
[Lock]: <../../operating system/并发/Lock.md> "Lock"
[图]: ../../algorithm/data_structure/图.md "图"
[进程|并行]: <../../operating system/虚拟化/进程.md> "进程"
[//end]: # "Autogenerated link references"

---
tags: python
---
# 协程

调用任务就像调用函数一样，是消耗资源最小的多任务。协程适合于需要等待的任务## async IO

## 关键字

- `async`：使用 `async` 之后，调用函数返回的是一个 coroutine 对象，传到 [[#event loop]] 里面才开始异步运行
- `await`：阻塞并等待一个 `async` 的协程对象/[[#Task 类]]/[[#Future]]执行完毕

## 例子

in jupyter-python we use `await main()`, but in python file we use `asyncio.run(main())`

```python
async def fetch_data():
    print("start fetching")
    await asyncio.sleep(2)
    return {"data":1}
async def print_num():
    for i in range(10):
        print(i)
        await asyncio.sleep(0.5)
async def main():
    task1 = asyncio.create_task(fetch_data())
    task2 = asyncio.create_task(print_num())
    tasks = [task1, task2]
    done, pending = await asyncio.wait(task, timeout=2) # 2s 后完成的放 done，没有完成的放 pending 返回
asyncio.run(main())
```

## event loop

我们可以让一个耗时的任务在后台运行。当这个任务完成的时候，event loop 可以 'pick it up'。

```python
result = []
def get_tasks(session):
    tasks = []
    for symbol in ["AAPL", "MSFT", "TSLA", "GOOG"]:
        tasks.append(session.get(url.format(symbol)))
async def get_symbols():
    async with aiohttp.ClientSession() as session:
        tasks = get_tasks(session)
        responses = asyncio.gather(*tasks)
        for response in responses:
            result.append(await response.json())
loop = asyncio.get_event_loop()
loop.run_until_complete(get_symbols())
loop.close()
# or
asyncio.run(get_symbols())
```

## Task 类

将一个 coroutine 对象通过 `asycio.create_task` 封装成 Task 对象(Future 类的子类)，可以获得任务执行的状态，进而对协程有更细致的控制

`task.result()` 在执行完成后得到 coroutine 的返回值

### 回调函数

callback 执行时间不确定，用于 task 任务执行完自动的操作，是同步函数，采用 `task.add_done_callback(callback)`

回调函数的参数是 task，只有一个。如果用其他参数需要 `partial` 才能回调

### Future

asyncio 中的 future 是[[#Task]]的基类，可以用 `loop.create_future()` 获得，基本不会手动获取

concurrent 的 `concurrent.futures.Future` 对象是使用 线程池/进程池 的异步

[//begin]: # "Autogenerated link references for markdown compatibility"
[#event loop]: 协程.md "协程"
[#Task 类]: 协程.md "协程"
[#Future]: 协程.md "协程"
[#Task]: 协程.md "协程"
[//end]: # "Autogenerated link references"

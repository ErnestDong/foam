---
tags: rust
---
# rust基础

## 变量绑定与解构

绑定不是赋值，见[[ownership]]

绝大多数情况下类型标注可以省略由编译器推断，但是函数参数必须标注类型。

```rust
let x = 5; // 默认不可变
let mut y = 5; // mut 可变
let (a, mut b) = (1, 2); // 解构
const MAX_POINTS: u32 = 100_000; // 常量
```

- rust也会存在整数溢出，但只在`debug`模式下检查。
- rust提供了序列，`1..5`为左闭右开区间，`1..=5`为左闭右闭区间。序列只允许用于数字或字符类型

## 函数

函数默认返回`()`，即空元组，可以使用`return`关键字返回值，不写`return`返回值为最后一行表达式的值(如果有`;`则最后一行表达式为空)。

```rust
fn function_name(x:type, y:type)->type{
    // function body
}
```

当用 `!` 作函数返回类型的时候，表示该函数永不返回(diverge function)，这种语法往往用做会导致程序崩溃的函数，比如 `panic!` 宏。

在 Rust 中，`self`一个指代当前的实例对象，`Self`指代特征或者方法类型的别名：

## 复合类型

### 字符串

切片就是对 String 等集合类型中某一部分的引用，它的类型是 `&str`，方法是`&s[0..5]`，左闭右开。注意这里的开闭区间是针对字节的，而不是针对字符的，汉字一个字符占三个字节。

### 元组

可以模式匹配解构，`let (x, y, z) = tup;`，也可以用`let x = tup.0;`访问。

### 结构体

结构体更新可以类似[[javascript]]，`user2=User{email:String::from(""),..user1}`

### `Vector`与`HashMap`

- 可以使用宏 `vec!` 来创建数组，能在创建同时给予初始化值，不用`Vec::new` 后`push`
- `Vector`可以用`.1`或`.get(1)`访问第二个元素，但`get`访问不存在元素返回`None`
- `HashMap`需要手动`use std::collections::HashMap;`
- 其他类型转换为`HashMap`时，可以`let teams_map: HashMap<_,_> = teams_list.into_iter().collect();`，先转换为迭代器再`collect`，需要标注类型

## 流程控制

### `if`

`if` 语句的返回值可以赋值给变量(为了规避[[lifetime]])，返回值必须相同，比如：

```rust
let number = if condition {
    5
} else {
    6 // 不能是 "six"
};
```

### `for`

通常采用引用的方式避免[[ownership]]转移，比如：

```rust
for item in &container {
  // ...
}
```

循环也可以采用`while`或`loop`

## [[模式匹配]]

## 方法

rust 使用 `impl` 来定义方法

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // Circle的方法，&self表示借用当前的Circle结构体
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
    // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}
```

- `self` 表示 `Circle` 的所有权转移到该方法中，这种形式用的较少
- `&self` 表示该方法对 `Circle` 的不可变借用
- `&mut self` 表示可变借用

当使用 `object.something()` 调用方法时，Rust 会自动为 `object` 添加 `&`、`&mut` 或 `*` 以便使 object 与方法签名匹配，因而不存在[[cpp]]的`->`

## 泛型 Generics

类似[[cpp]]里面的模版，只不过不想要预先定义`template`。但由于 `T` 可以是任何类型，但不是所有的类型都能加，需要用 `std::ops::Add<Output = T>` 这个[[trait]]对 `T` 进行限制：

```rust
fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
    a + b
}
```

泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码

## 错误处理

`panic!`宏会在发生错误时停止程序，`Result`类型是一个枚举，包含`Ok`和`Err`，`Ok`表示成功，`Err`表示失败，`Result`类型的值可以使用`match`或`unwrap`来处理

```rust
use std::fs::File;
fn main() {
    let f = File::open("hello.txt").unwrap();
    // let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```

`?`运算符可以简化`match`，并可以链式使用，比如：

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[ownership]: ../concept/ownership.md "ownership"
[javascript]: ../../javascript/javascript.md "javascript"
[lifetime]: ../concept/lifetime.md "lifetime"
[模式匹配]: 模式匹配.md "模式匹配"
[cpp]: ../../cpp/cpp.md "Cpp"
[trait]: ../concept/trait.md "trait"
[//end]: # "Autogenerated link references"

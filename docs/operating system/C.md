---
tags: CS
---
# C

## 程序就是状态机

C 语言的状态是 stack frame + PC + 全局变量，每执行一条语句状态就变一下。
初始状态是 `main(argc,argv)` ，迁移是执行 top frame 的 PC 语句，函数调用 push frame，返回 pop frame。

二进制文件下，也可以将程序看作是内存 M 和寄存器 R 的状态机。初始状态是加载 `加载器` libc，`main` 并非是程序的开始/结束。
在操作系统中，将程序看作是“计算”+ `syscall`，`syscall`利用中断把程序的状态全部交给操作系统，任其修改

两种状态机之间的映射是编译器，C 所有不可优化的部分都被翻译成了汇编。
**各种程序都在操作系统API `syscall` 和操作系统中的对象上构建**

## pthread.h

用于 [[多线程]] [[并发]]编程

线程的创建是在状态中新增一个栈帧列表并初始化；
线程的等待是在其他线程未执行完成时死循环。

### 原子性

程序/指令独占处理器执行的假设不成立，需要非原子操作上加锁。

绝大多数并发问题可以用一个队列解决：把大任务分解为小任务，worker thread去锁保护的队列里面取任务

### 顺序

编译器按照单线程程序优化代码，导致共享内存作为线程同步的失效

### 可见性

处理器也是一种状态机，会把汇编进一步编译成 $\mu$ ops，因为有乱序执行甚至投机执行、按序提交，多处理器上无法序列化，可能导致cache没有命中时先执行后面的代码

## libc 的实现

### 系统调用和计算的封装

### 文件描述符和进程状态的封装：`fopen` 和 `popen`

文件描述符是一个指向操作系统内的指针，只能通过操作系统允许的方式操作。文件描述符有一个偏移量。
文件描述符的写是原子的

### `malloc` 和 `free`

是区间管理的问题。对于内存区间 [L, R)，`malloc(s)` 是分配一段长 s 的合法内存。不是考虑 worst case，而是考虑小对象要快，大对象可以慢一些，并且倾向于[[并发]]分配

解决方法是设置两套系统(类似cache)

- fast path：性能好、并行度高、覆盖大部分情况，但是小概率会失败
  - 不需要上锁，线程在自己的 page(64kb) 上分配
    - 64kb 是因为地址对齐容易分配 2 的幂次
  - 如果 page 不够，向全局管理 page 的链表申请
  - 回收直接归还到 page 中
- slow path：不在乎快慢，但把困难的事情做好

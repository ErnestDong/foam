---
tags: Cpp
---

# Cpp

[[C]] with class & [[stl]]

## [[oop]]

### init

类如果没有显式的声明以下六种函数，[[compile]]r 会自动添加（需要的时候才添加），而且都不会被派生类继承：

- 构造函数
- 析构函数
- 拷贝构造函数
- 重载赋值操作符函数
- 取址运算符重载函数
- const 取址运算符重载函数

```cpp
class A {
  public:
    A();
    ~A();
    A(const A &);
    A &      operator=(const A &);
    A *      operator&();
    const A *operator&() const;
}
```

### 拷贝构造、重载

在声明的时候将一个已经存在的对象赋值给他，调用的是拷贝构造函数；

如果对象已经存在，将另一个对象赋值给他，调用的就是重载赋值操作符函数

在传递参数或者是函数返回值时，如果不是引用，则会调用拷贝构造函数。

```cpp
#include <iostream>
using namespace std;

class CTest {
  public:
    CTest() {
        cout << "init." << endl;
    }
    CTest(const CTest &test) {
        cout << "copy constructor." << endl;
    }
    void operator=(const CTest &test) {
        cout << "operator=" << endl;
    }
    void Test(CTest test) {
    }
    CTest Test2() {
        CTest a;
        return a;
    }
    void Test3(CTest &test) {
    }
    CTest &Test4() {
        CTest *pA = new CTest;
        return *pA;
    }
};

int main() {
    CTest obj;
    CTest obj1(obj); // 调用复制构造函数
    obj1 = obj; // 调用重载赋值操作符
    /* 传参的过程中，要调用一次复制构造函数
     * obj1入栈时会调用复制构造函数创建一个临时对象，与函数内的局部变量具有相同的作用域
     */
    obj.Test(obj1);
    /* 函数返回值时，调用复制构造函数；将返回值赋值给obj2时，调用重载赋值操作符
     * 函数返回值时，也会构造一个临时对象；调用复制构造函数将返回值复制到临时对象上
     */
    CTest obj2;
    obj2 = obj.Test2();
    obj2.Test3(obj); // 参数是引用，没有调用复制构造函数
    CTest obj3;
    obj2.Test4(); // 返回值是引用，没有调用复制构造函数
    return 0;
}
```

### 委托构造

### virtual

函数继承的是调用权

- 非虚函数：不希望子类被 override
- 虚函数 virtual：希望子类 override，并提供了默认定义
- 纯虚函数 virtual const=0：子类必须 override，且不能实例化

## 内存管理

### 堆栈

[[栈]]是程序自动生成的，生命期在作用域内；static 对象在程序结束时生命期结束

[[堆]]是手动管理的，delete 之后指向对象生命期结束

### new & delete

new 先分配内存（内部调用 malloc），然后转型（static_cast），再调用构造函数

delete 先调用析构函数，再释放内存（内部调用 free）

new String[3] 一定要调用 delete[] \*p 是因为这样才能调用多次析构函数

### static

静态数据多个对象共享一份

静态函数没有 this 指针，只能处理静态数据，可以用对象调用或类名直接调用

## [[多线程]]

避免死锁的两种方式：

- RAII：用 `lock_guard` 或 `unique_lock`(支持操作更多) 模版来避免忘记释放[[Lock]](`std::lock_guard<std::mutex> lock(mutex)`)
- 上锁顺序：按顺序上锁/给锁上锁(`std::lock(mtx1,mtx2)`)

或者采用 `std::atomic` 模版来保护竞争的资源

```cpp
#include <chrono>
#include <iostream>
#include <thread>

void thread() {
    std::cout << std::this_thread::get_id() << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
}

int main() {
    std::cout << std::this_thread::get_id() << std::endl;
    std::thread th{thread};
    th.join();
    return 0;
}
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[C]: C.md "C"
[stl]: stl.md "STL"
[compile]: ../compilers/compile.md "编译原理"
[栈]: ../algorithm/data_structure/栈.md "栈"
[堆]: ../algorithm/data_structure/堆.md "堆"
[多线程]: ../python/multitasks/多线程.md "多线程"
[Lock]: <../operating system/并发/Lock.md> "Lock"
[//end]: # "Autogenerated link references"
